
Certainly! I'll incorporate the technical details you've provided into the draft, highlighting how we leveraged BigQuery's powerful jobs model, optimized SQL queries, efficient partitioning, caching mechanisms, and result streaming in Avro format. This will emphasize the efficiency and cost-effectiveness of our solution without overwhelming the reader with technical jargon.


---

Story Title: Optimizing Risk Data Access with the Risk Warehouse API

Story Intro:

Our team has significantly improved scalability and enhanced efficiency by developing the Risk Warehouse API, a solution that creates substantial functional value for the business. By consolidating multiple query endpoints into a single, powerful interface, we have streamlined risk data access and empowered users to retrieve precise information quickly and securely.

Group: ESFHOF2024

Tags:

Award Categories: HOFBusinessOutcome, HOFInnovator, HOFStrategicTech

Functional Area: HOFDerivs


Collaborators: [Our dedicated development team]


---

The Problem/Opportunity:

We faced the challenge of providing a large number of users with access to an immense volume of risk data generated from risk runs. These runs produce billions of data points per execution, with hundreds of runs occurring daily—amounting to trillions of data points that need to be stored, processed, and accessed efficiently. The specific challenges included:

Storage Limitations: The need to store trillions of data points per day without incurring prohibitive costs.

Performance Issues: Processing vast amounts of data without degrading the user experience.

Redundancy: Avoiding wasteful storage and CPU usage due to redundant data and computations.

Data Management: Developing a strategy to manage and archive data effectively over time.

User Accessibility: Enabling users to navigate, aggregate, and drill down into data efficiently for analysis and decision-making.


Business Area/Function: Risk Management and Data Analytics

Solution Summary (50 words):

We developed the Risk Warehouse API—a unified, powerful query endpoint backed by a robust data dictionary and a generic JSON query language. Leveraging BigQuery's powerful jobs model, optimized SQL generation, efficient partitioning, and caching mechanisms, we enable users to fetch precisely the data they need, optimizing performance and reducing costs.

Asset Class & Pod Name: Derivatives | Risk Warehouse API Pod

Business Outcome (story/nomination):

The Risk Warehouse API revolutionized risk data access by consolidating multiple endpoints into one, enhancing performance, and reducing costs. By efficiently utilizing BigQuery's capabilities, optimizing our SQL queries, and implementing smart caching, users can now retrieve and analyze large datasets quickly. Results are streamed in Avro format, which integrates seamlessly with data analysis tools like Python Pandas, facilitating efficient downstream analysis. This approach not only improves performance but also reduces costs by ensuring users access only the data they need, avoiding unnecessary data processing and storage.


---

Key Business Outcomes and Impact:

Enhanced Performance:

Optimized SQL Queries: By refining our SQL generation, we've reduced query execution times, allowing users to display large reports within 20 seconds.

Efficient Partitioning: Utilizing BigQuery's partitioning capabilities, we process only relevant data segments, improving speed and resource utilization.

Caching Mechanisms: Implementing intelligent caching for frequently accessed data minimizes redundant computations and accelerates data retrieval.


Improved Scalability:

BigQuery's Powerful Jobs Model: Leveraging this model enables us to handle trillions of data points daily without performance degradation, ensuring the system scales with growing data volumes.


Cost Reduction:

Selective Data Access: Users request only the specific data they need, which reduces data processing costs and storage requirements.

Optimized Resource Usage: Efficient SQL and partitioning reduce compute costs by minimizing unnecessary data scans.

Streaming in Avro Format: This data format is compact and efficient, reducing data transfer costs and enhancing compatibility with analysis tools.


User Empowerment:

Generic JSON Query Language: Provides flexibility for users to specify precise data requirements, improving productivity.

Seamless Integration with Analysis Tools: Avro-formatted results work efficiently with tools like Python Pandas, facilitating advanced data analysis.


Data Management Strategy:

Effective Data Archiving: Supports near-line and cold-line data storage options, providing a sustainable and cost-effective approach to long-term data management.



An Analogy to Illustrate Our API's Versatility:

Our Risk Warehouse API functions like a Swiss Army Knife for data access—a single, versatile tool equipped with multiple functionalities to meet the diverse needs of various applications. By providing one powerful interface backed by efficient data processing techniques, we've created a solution that is both adaptable and efficient, much like a Swiss Army Knife simplifies multiple tasks with its array of tools.

Supporting Evidence or Metrics:

Performance Improvements:

Reduced report generation times from several minutes to under 20 seconds through optimized SQL and efficient partitioning.


Cost Savings:

Significant reductions in storage and compute costs by avoiding unnecessary data processing and leveraging caching mechanisms.


User Adoption:

High adoption rates with positive feedback on improved efficiency, ease of use, and compatibility with data analysis tools.


Data Volume Handling:

Successfully managing trillions of data points per day without performance issues, thanks to BigQuery's jobs model and our optimizations.



Additional Information:

By streaming results in Avro format, we provide data that's highly compatible with analysis tools like Python Pandas, enabling users to perform advanced analytics with ease. Our approach ensures that users access only the data they need, enhancing both performance and cost-effectiveness. The Risk Warehouse API not only addresses current operational challenges but also positions us strategically for future technological advancements. By optimizing every layer—from SQL generation to data streaming—we've created a robust, efficient, and versatile solution that supports sustained business growth and innovation.


---

I hope this updated draft effectively incorporates the technical details you wanted to highlight, presenting them in a clear and accessible manner. Let me know if there's anything else you'd like to add or adjust!




Here’s the updated Jira ticket with simplified filters and an example GET query:


---

Ticket Title:

Create Flexible Job Explorer API Endpoint with Date Range, Job ID, and Job Type Filters for Firestore


---

Ticket Type:

Feature


---

Description:

Design and implement a flexible API endpoint in Firestore to retrieve the latest version of job documents from the "jobs" collection. The API should support filtering based on a date range (rollDate), specific job IDs (single or multiple), and job types (as an array). The endpoint should return only the latest version of each job and be documented in Swagger UI for ease of use.


---

Requirements:

1. API Endpoint:

Endpoint: /jobs

HTTP Method: GET

Purpose: Retrieve the latest version of job documents with flexible filtering options.



2. Parameters:

rollDate (Date Range): Filter jobs based on a date range.

startDate (string, date format): Start date for the roll date range.

endDate (string, date format): End date for the roll date range.


jobId: Filter by job ID(s); accepts a single job ID or a list of job IDs.

jobId (string or array of strings): Unique identifier(s) for jobs to retrieve.


jobType: Filter by job type(s).

jobType (array of strings): Job type categories to filter by.




3. Logic:

Latest Version: Automatically retrieve only the latest version of each job, using a version or updatedAt field to identify the most recent.

Filtering: Limit filtering to the specified fields (rollDate date range, jobId, and jobType) for simplicity.

Pagination and Sorting:

Include limit and page query parameters for pagination.

Default sorting by updatedAt in descending order.




4. Swagger UI Integration:

Interactive Documentation: Document the API in Swagger, specifying all parameters and their usage.

Examples: Provide sample requests in Swagger to illustrate different filter combinations.

Parameter Descriptions: Clearly document the purpose of each parameter.



5. Response:

Format: JSON array of job objects.

Fields: Return all fields in each job document.

Error Handling: Implement error handling for invalid parameters or query formats.



6. Example GET Query:

Example: Retrieve active jobs of types "engineering" and "management" within a specific date range, limiting results to the latest version:

GET /jobs?startDate=2024-01-01&endDate=2024-12-31&jobId=123,456&jobType=engineering,management&limit=10&page=1





---

Acceptance Criteria:

1. The /jobs endpoint retrieves only the latest version of each job, based on the updatedAt or version field.


2. Filters for rollDate (using startDate and endDate), jobId (single or multiple), and jobType (array) are functional and documented in Swagger.


3. The API includes pagination (limit and page parameters) and default sorting by updatedAt in descending order.


4. Swagger UI is configured with parameter descriptions and usage examples.


5. Response is formatted in JSON, containing all job fields by default.


6. Error handling is implemented for invalid or missing parameters.




---

Priority:

High

Story Points:

5


---

This refined approach simplifies the filters and keeps the API focused on core needs, making it more efficient to implement and easier for clients to use. Let me know if there are any further adjustments needed!


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Query Builder</title>
    
    <!-- jQuery CDN -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    
    <!-- jQuery QueryBuilder CSS and JS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jQuery-QueryBuilder/dist/css/query-builder.default.min.css">
    <script src="https://cdn.jsdelivr.net/npm/jQuery-QueryBuilder/dist/js/query-builder.standalone.min.js"></script>

    <style>
        /* Custom CSS for layout */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #builder {
            flex: 1;
            padding: 20px;
            background-color: #f8f9fa;
        }
        #json-display {
            height: 200px;
            padding: 20px;
            background-color: #ffffff;
            border-top: 1px solid #ddd;
            position: relative;
        }
        #json-output {
            width: 100%;
            height: 150px;
            font-family: monospace;
            border: 1px solid #ccc;
            padding: 10px;
            box-sizing: border-box;
            resize: none;
        }
        #copy-button {
            position: absolute;
            right: 20px;
            bottom: 10px;
            padding: 8px 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <!-- Query Builder Section -->
    <div id="builder"></div>

    <!-- JSON Output and Copy Button Section -->
    <div id="json-display">
        <textarea id="json-output" readonly></textarea>
        <button id="copy-button">Copy to Clipboard</button>
    </div>

    <script>
        // Initialize the Query Builder with basic fields
        $('#builder').queryBuilder({
            filters: [
                {
                    id: 'jobIds',
                    label: 'Job IDs',
                    type: 'string',
                    input: 'text',
                    operators: ['equal', 'not_equal', 'in', 'not_in'],
                },
                {
                    id: 'field',
                    label: 'Field',
                    type: 'string',
                    input: 'select',
                    values: {
                        'Result_snap': 'Result_snap',
                        'Result_context': 'Result_context',
                        'Result_EPI': 'Result_EPI',
                        'Result_HMSBook': 'Result_HMSBook',
                        'Result_JobId': 'Result_JobId',
                        'Result_InstrumentId': 'Result_InstrumentId',
                        'Result_Errors': 'Result_Errors'
                    },
                    operators: ['equal', 'not_equal']
                },
                {
                    id: 'aggFunc',
                    label: 'Aggregation Function',
                    type: 'string',
                    input: 'select',
                    values: {
                        'sum': 'sum',
                        'avg': 'avg',
                        'min': 'min',
                        'max': 'max',
                        'count': 'count',
                        'any_value': 'any_value'
                    }
                },
                {
                    id: 'pivot',
                    label: 'Pivot',
                    type: 'string',
                    operators: ['equal', 'not_equal']
                }
            ]
        });

        // Update JSON output whenever the query is updated
        $('#builder').on('afterUpdateRuleValue afterUpdateRuleFilter afterDeleteRule afterCreateRule', function() {
            var rules = $('#builder').queryBuilder('getRules');
            if (!$.isEmptyObject(rules)) {
                $('#json-output').val(JSON.stringify(rules, null, 2));
            } else {
                $('#json-output').val('');
            }
        });

        // Copy JSON to Clipboard
        $('#copy-button').on('click', function() {
            const jsonOutput = document.getElementById('json-output');
            jsonOutput.select();
            document.execCommand('copy');
            alert('JSON copied to clipboard!');
        });
    </script>

</body>
</html>



openapi: 3.0.1
info:
  title: Warehouse API
  version: 1.0.0
paths:
  /warehouse:
    post:
      summary: Submit a warehouse request
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/WarehouseRequest'
            examples:
              example1:
                summary: Example Request
                value:
                  jobIds:
                    - "2ab3909d-f423-4d61-aa94-30d8f0a6d918"
                  valueCols:
                    - field: "Result_snap"
                      aggFunc: "sum"
                    - field: "Result_context"
                      aggFunc: "avg"
                  pivot:
                    aggColumn: "Result_Exposure_Value"
                    pivotColumn: "Result_MultipriceStep"
                    pivotValues:
                      - "RollBasedPnL"
                      - "PortfolioPnL"
      responses:
        '200':
          description: Successful response
components:
  schemas:
    WarehouseRequest:
      type: object
      properties:
        jobIds:
          type: array
          items:
            type: string
          description: List of Job IDs
        valueCols:
          type: array
          items:
            $ref: '#/components/schemas/ColumnVO'
          description: List of value columns
        aggregation:
          type: array
          items:
            type: string
            enum:
              - Result_EPI
              - Result_Exposure_RiskFactor1
              - Result_Exposure_RiskFactor2
              - Result_Exposure_InstrumentId
          description: Aggregation columns
        pivot:
          $ref: '#/components/schemas/Pivot'
        filterModel:
          type: object
          additionalProperties:
            $ref: '#/components/schemas/ColumnFilter'
          description: Filter model for additional query filters
      required:
        - jobIds
        - valueCols
    ColumnVO:
      type: object
      properties:
        field:
          type: string
          enum:
            - Result_snap
            - Result_context
            - Result_EPI
            - Result_HMSBook
            - Result_JobId
            - Result_InstrumentId
            - Result_Errors
            - Result_PortfolioId
            - Result_LegalEntity
            - Result_Desk
          description: Field name
        aggFunc:
          type: string
          enum:
            - sum
            - avg
            - min
            - max
            - count
            - any_value
          description: Aggregation function (required if 'aggregation' exists)
    Pivot:
      type: object
      properties:
        aggColumn:
          type: string
          description: Aggregation column
        pivotColumn:
          type: string
          description: Pivot column
        pivotValues:
          type: array
          items:
            type: string
            enum:
              - RollBasedPnL
              - PortfolioPnL
              - HypoPnL
              - UnexplainedHypo
              - ThetaPnL
              - FxSpotPnL
          description: Pivot values
      required:
        - aggColumn
        - pivotColumn
        - pivotValues
    ColumnFilter:
      type: object
      properties:
        filterType:
          type: string
          enum:
            - set
            - range
            - date
            - text
          description: Type of filter to apply
        values:
          type: array
          items:
            type: string
          description: Values to filter by (for set-type filters)
        range:
          type: object
          properties:
            start:
              type: string
              format: date-time
              description: Start of the range (for range-type filters)
            end:
              type: string
              format: date-time
              description: End of the range (for range-type filters)
        text:
          type: string
          description: Text-based filter input
      description: Column filter options for filtering query results


openapi: 3.0.1
info:
  title: Warehouse API
  version: 1.0.0
paths:
  /warehouse:
    post:
      summary: Submit a warehouse request
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/WarehouseRequest'
      responses:
        '200':
          description: Successful response
components:
  schemas:
    WarehouseRequest:
      type: object
      properties:
        jobIds:
          type: array
          items:
            type: string
          description: List of Job IDs
        valueCols:
          type: array
          items:
            $ref: '#/components/schemas/ColumnVO'
          description: List of value columns
        aggregation:
          type: array
          items:
            type: string
            enum:
              - Result_EPI
              - Result_Exposure_RiskFactor1
              - Result_Exposure_RiskFactor2
              - Result_Exposure_InstrumentId
          description: Aggregation columns
        filterModel:
          type: object
          additionalProperties:
            $ref: '#/components/schemas/ColumnFilter'
        pivot:
          $ref: '#/components/schemas/Pivot'
        distinct:
          type: boolean
          default: false
        exportFormat:
          type: string
          enum:
            - avro
            - json
            - csv
          default: avro
      required:
        - jobIds
        - valueCols
      allOf:
        # Conditional validation: If 'aggregation' is present and not empty, then 'aggFunc' in 'valueCols' is required
        - if:
            properties:
              aggregation:
                minItems: 1
          then:
            properties:
              valueCols:
                type: array
                items:
                  $ref: '#/components/schemas/ColumnVOWithAggFunc'
    ColumnVO:
      type: object
      properties:
        field:
          type: string
          description: Field name
          enum:
            - Result_snap
            - Result_context
            - Result_EPI
            - Result_HMSBook
            - Result_JobId
            - Result_InstrumentId
            - Result_Errors
            - Result_PortfolioId
            - Result_LegalEntity
            - Result_Desk
        displayName:
          type: string
          description: Display name
    ColumnVOWithAggFunc:
      allOf:
        - $ref: '#/components/schemas/ColumnVO'
        - type: object
          properties:
            aggFunc:
              type: string
              description: Aggregation function
              enum:
                - sum
                - avg
                - min
                - max
                - count
                - any_value
          required:
            - aggFunc
    Pivot:
      type: object
      properties:
        aggColumn:
          type: string
          description: Aggregation column
        pivotColumn:
          type: string
          description: Pivot column
        pivotValues:
          type: array
          items:
            type: string
            enum:
              - RollBasedPnL
              - PortfolioPnL
              - HypoPnL
              - UnexplainedHypo
              - ThetaPnL
              - FxSpotPnL
      required:
        - aggColumn
        - pivotColumn
        - pivotValues


Sure! Here are the detailed examples for parts 4, 5, and 6 of the client's documentation.

### 4. Building a Query in JSON

**Structure of the JSON Request**
- The JSON request structure is designed to build SQL queries dynamically. Below is the general structure:

```json
{
  "noPagination": false,
  "pageNumber": 1,
  "pageSize": 10,
  "rowGroupCols": [
    {"field": "tablePrefix.columnName", "displayName": "columnAlias", "aggFunc": "aggregationFunction"}
  ],
  "valueCols": [
    {"field": "tablePrefix.columnName", "displayName": "columnAlias", "aggFunc": "aggregationFunction"}
  ],
  "selectCols": ["tablePrefix.columnName"],
  "groupKeys": [],
  "pivotColumn": "tablePrefix.columnName",
  "pivot": {
    "aggColumn": "tablePrefix.columnName",
    "pivotColumn": "tablePrefix.columnName",
    "pivotValues": ["value1", "value2"]
  },
  "filterModel": {
    "tablePrefix.columnName": {"values": ["value1", "value2"], "filterType": "set"}
  },
  "sortModel": [
    {"colId": "tablePrefix.columnName", "sort": "asc"}
  ]
}
```

**Detailed Explanation of Each JSON Field**

- `noPagination`: Boolean to disable pagination.
- `pageNumber`: The page number for pagination.
- `pageSize`: The size of each page.
- `rowGroupCols`: List of columns to group by. Each item should have:
  - `field`: The column name prefixed with the table alias.
  - `displayName`: An alias for the column in the results.
  - `aggFunc`: The aggregation function to apply (e.g., `SUM`, `COUNT`).
- `valueCols`: List of columns to aggregate. Each item should have:
  - `field`: The column name prefixed with the table alias.
  - `displayName`: An alias for the column in the results.
  - `aggFunc`: The aggregation function to apply.
- `selectCols`: List of columns to select.
- `groupKeys`: List of group keys.
- `pivotColumn`: Column to pivot on.
- `pivot`: An object containing:
  - `aggColumn`: Column to aggregate in the pivot.
  - `pivotColumn`: Column to pivot on.
  - `pivotValues`: List of values to pivot.
- `filterModel`: A map of filters. Each filter should have:
  - `values`: List of values to filter.
  - `filterType`: The type of filter (`set`, `number`, etc.).
- `sortModel`: List of sorting instructions. Each item should have:
  - `colId`: The column to sort by.
  - `sort`: The sort direction (`asc`, `desc`).

**Example JSON Queries**

1. **Basic Query**

```json
{
  "noPagination": false,
  "pageNumber": 1,
  "pageSize": 10,
  "rowGroupCols": [
    {"field": "cust.customerId", "displayName": "customerId", "aggFunc": null}
  ],
  "valueCols": [
    {"field": "ord.totalAmount", "displayName": "totalAmount", "aggFunc": "SUM"}
  ],
  "selectCols": ["cust.customerId", "ord.totalAmount"],
  "groupKeys": [],
  "filterModel": {
    "cust.customerId": {"values": ["123", "456"], "filterType": "set"}
  },
  "sortModel": [
    {"colId": "cust.customerId", "sort": "asc"}
  ]
}
```

2. **Pivot Query**

```json
{
  "noPagination": false,
  "pageNumber": 1,
  "pageSize": 10,
  "rowGroupCols": [
    {"field": "cust.customerId", "displayName": "customerId", "aggFunc": null},
    {"field": "ord.orderId", "displayName": "orderId", "aggFunc": null}
  ],
  "valueCols": [
    {"field": "ord.totalAmount", "displayName": "totalAmount", "aggFunc": "SUM"}
  ],
  "selectCols": ["cust.customerId", "ord.orderId", "ord.totalAmount"],
  "groupKeys": [],
  "pivotColumn": "ord.orderStatus",
  "pivot": {
    "aggColumn": "ord.totalAmount",
    "pivotColumn": "ord.orderStatus",
    "pivotValues": ["completed", "pending"]
  },
  "filterModel": {
    "cust.customerId": {"values": ["123", "456"], "filterType": "set"},
    "ord.totalAmount": {"filter": 100, "type": "greaterThan"}
  },
  "sortModel": [
    {"colId": "cust.customerId", "sort": "asc"}
  ]
}
```

### 5. API Endpoints

**List of Available Endpoints**

- **POST /api/v1/query**
  - Description: Generates a SQL query based on the JSON input.
  - Request Body: JSON object with query parameters.
  - Response: JSON object with the generated SQL query.

**Detailed Explanation of Each Endpoint**

**POST /api/v1/query**

- **URL**: `/api/v1/query`
- **HTTP Method**: `POST`
- **Description**: This endpoint generates a SQL query based on the JSON input provided.
- **Request Body**: The JSON request body should follow the structure described in the "Building a Query in JSON" section.
- **Response**:
  - `query`: The generated SQL query.

**Example API Requests and Responses**

**Request:**

```http
POST /api/v1/query
Content-Type: application/json

{
  "noPagination": false,
  "pageNumber": 1,
  "pageSize": 10,
  "rowGroupCols": [
    {"field": "cust.customerId", "displayName": "customerId", "aggFunc": null},
    {"field": "ord.orderId", "displayName": "orderId", "aggFunc": null}
  ],
  "valueCols": [
    {"field": "ord.totalAmount", "displayName": "totalAmount", "aggFunc": "SUM"}
  ],
  "selectCols": ["cust.customerId", "ord.orderId", "ord.totalAmount"],
  "groupKeys": [],
  "pivotColumn": "ord.orderStatus",
  "pivot": {
    "aggColumn": "ord.totalAmount",
    "pivotColumn": "ord.orderStatus",
    "pivotValues": ["completed", "pending"]
  },
  "filterModel": {
    "cust.customerId": {"values": ["123", "456"], "filterType": "set"},
    "ord.totalAmount": {"filter": 100, "type": "greaterThan"}
  },
  "sortModel": [
    {"colId": "cust.customerId", "sort": "asc"}
  ]
}
```

**Response:**

```json
{
  "query": "SELECT cust.customerId, ord.orderId, SUM(ord.totalAmount) as totalAmount FROM Customers AS cust LEFT JOIN UNNEST(cust.orders) AS ord WHERE cust.customerId IN ('123', '456') AND ord.totalAmount > 100 GROUP BY cust.customerId, ord.orderId ORDER BY cust.customerId asc PIVOT (SUM(ord.totalAmount) FOR ord.orderStatus IN ('completed', 'pending'))"
}
```

### 6. Common Use Cases

**Examples of Common Queries**

1. **Filtering Data**
   - Filter customers with specific IDs and sum their order amounts.

**Example JSON:**
```json
{
  "noPagination": false,
  "pageNumber": 1,
  "pageSize": 10,
  "rowGroupCols": [
    {"field": "cust.customerId", "displayName": "customerId", "aggFunc": null}
  ],
  "valueCols": [
    {"field": "ord.totalAmount", "displayName": "totalAmount", "aggFunc": "SUM"}
  ],
  "selectCols": ["cust.customerId", "ord.totalAmount"],
  "groupKeys": [],
  "filterModel": {
    "cust.customerId": {"values": ["123", "456"], "filterType": "set"}
  },
  "sortModel": [
    {"colId": "cust.customerId", "sort": "asc"}
  ]
}
```

**Example SQL:**
```sql
SELECT cust.customerId, SUM(ord.totalAmount) as totalAmount
FROM Customers AS cust
LEFT JOIN UNNEST(cust.orders) AS ord
WHERE cust.customerId IN ('123', '456')
GROUP BY cust.customerId
ORDER BY cust.customerId asc
```

2. **Grouping Data**
   - Group orders by customer and order ID, and sum the total amount.

**Example JSON:**
```json
{
  "noPagination": false,
  "pageNumber": 1,
  "pageSize": 10,
  "rowGroupCols": [
    {"field": "cust.customerId", "displayName": "customerId", "aggFunc": null},
    {"field": "ord.orderId", "displayName": "orderId", "aggFunc": null}
  ],
  "valueCols": [
    {"field": "ord.totalAmount", "displayName": "totalAmount", "aggFunc": "SUM"}
  ],
  "selectCols": ["cust.customerId", "ord.orderId", "ord.totalAmount"],
  "groupKeys
