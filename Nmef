
# ADR001 - Separate Endpoints for Query Execution and File Retrieval

## Status
**Accepted**

---

## Context

Our current service processes a user query through the following steps:
1. Generates SQL from the query model.
2. Executes the query in BigQuery.
3. Exports the results to a GCS bucket.
4. Streams the binary content of the results back to the user.

Initially, we had a single synchronous endpoint to handle this entire process. However, we encountered the following challenges:
- **Long Query Execution Times**: Some queries take too long to execute, causing the client to time out.
- **BigQuery Export Size Limitation**: BigQuery has a maximum export file size of 1GB. For results larger than 1GB, the export must be split into multiple files.
- **Complex Aggregation**: Streaming back aggregated results from multiple files to the user became complex and error-prone.

To address these challenges, we decided to separate the functionality into two distinct endpoints.

---

## Options Considered

### Option 1: Separate Endpoints for Query Execution and File Retrieval
- **Description**: Create two endpoints:
  1. An endpoint to launch the query, which returns metadata, including links to the generated result files in GCS.
  2. An endpoint to retrieve the content of a specific result file by its link or identifier.

- **Pros**:
  - Decouples long-running query execution from result streaming.
  - Simplifies the streaming process since each file can be fetched individually.
  - Supports BigQuery’s split-export functionality natively.
  - Allows better handling of large result sets and timeouts.
  - Improves scalability by enabling asynchronous processing.

- **Cons**:
  - Requires the client to make multiple requests (one to launch the query, and another to fetch results).
  - Additional complexity in tracking the status of the query and managing links to result files.

---

### Option 2: Keep the Single Synchronous Endpoint
- **Description**: Continue using a single synchronous endpoint that handles query execution, exporting, and streaming the results back to the user.

- **Pros**:
  - Simpler for the client since only one request is needed.
  - No need for the client to handle metadata or track result files.

- **Cons**:
  - Timeout issues with long-running queries.
  - Cannot handle results exceeding BigQuery’s 1GB export size.
  - Aggregating and streaming large results back to the user is complex and error-prone.
  - Limited scalability and prone to failures under heavy load.

---

## Decision

We decided to implement **Option 1: Separate Endpoints for Query Execution and File Retrieval**.  
This approach addresses the timeout and export size limitations, simplifies the result streaming process, and supports asynchronous workflows for large result sets.

---

## Consequences

1. **Implementation Changes**:
   - Create two endpoints:
     - **Query Execution Endpoint**: Accepts the query model and triggers the BigQuery job. Returns metadata with links to the exported result files.
     - **File Retrieval Endpoint**: Accepts a file link or identifier and streams the content of the specified file to the user.
   - Store metadata about the result files, including their links, in a persistent data store if needed.

2. **Client-Side Changes**:
   - Clients must first call the Query Execution Endpoint to get the metadata and then use the File Retrieval Endpoint to fetch the results.

3. **Monitoring and Error Handling**:
   - Implement robust monitoring for query execution and file exports.
   - Ensure retry mechanisms for file retrieval in case of transient errors.

4. **Performance and Scalability**:
   - Improves scalability by decoupling query execution from result streaming.
   - Handles large result sets efficiently with BigQuery’s split-export feature.

---

## See Also

- [BigQuery documentation on Exporting Data](https://cloud.google.com/bigquery/docs/exporting-data)
- [GCS documentation on Managing Objects](https://cloud.google.com/storage/docs/objects)
<!DOCTYPE html>
<html>
<head>
    <title>Architecture Decision Records (ADR) Guidelines</title>
</head>
<body>
    <h1>Architecture Decision Records (ADR) Guidelines</h1>
    
    <h2>What is an ADR?</h2>
    <p>An <strong>Architecture Decision Record (ADR)</strong> documents architectural decisions made within a project, including the options considered, their pros and cons, and the final decision. ADRs help teams maintain a history of decisions for clarity and alignment over time.</p>
    <p>For more details on ADRs, refer to <a href="https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions" target="_blank">Documenting Architecture Decisions by Michael Nygard</a>.</p>

    <h2>Naming Conventions for ADRs</h2>
    <p>Each ADR should follow this naming convention:</p>
    <pre><code>ADR### - Short Title of the Decision</code></pre>
    <ul>
        <li><strong>###</strong>: Incremental number starting from <code>001</code>.</li>
        <li><strong>Short Title</strong>: Briefly describes the decision. Example:
            <ul>
                <li>ADR001 - Use an SQS Queue to Manage Mail</li>
                <li>ADR002 - Choose PostgreSQL as the Database</li>
            </ul>
        </li>
    </ul>

    <h2>ADR Template with Options</h2>
    <p>Here’s the template we will follow for ADRs:</p>
    <ol>
        <li><strong>Title</strong>: A clear and concise name for the decision.</li>
        <li><strong>Status</strong>: Current status of the ADR: <em>Proposed</em>, <em>Accepted</em>, <em>Superseded</em>, or <em>Deprecated</em>.</li>
        <li><strong>Context</strong>: 
            <ul>
                <li><em>What is the problem?</em> Provide background information and the factors leading to this decision.</li>
                <li><em>Why is this decision needed now?</em> Explain the urgency or importance.</li>
            </ul>
        </li>
        <li><strong>Options Considered</strong>: List the options evaluated, with their pros and cons. For each option:
            <ul>
                <li><strong>Option 1: [Option Name]</strong>
                    <ul>
                        <li><strong>Description</strong>: Brief explanation of the option.</li>
                        <li><strong>Pros</strong>:
                            <ul>
                                <li>Advantage 1</li>
                                <li>Advantage 2</li>
                            </ul>
                        </li>
                        <li><strong>Cons</strong>:
                            <ul>
                                <li>Disadvantage 1</li>
                                <li>Disadvantage 2</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Option 2: [Option Name]</strong>
                    <ul>
                        <li><strong>Description</strong>: Brief explanation of the option.</li>
                        <li><strong>Pros</strong>:
                            <ul>
                                <li>Advantage 1</li>
                                <li>Advantage 2</li>
                            </ul>
                        </li>
                        <li><strong>Cons</strong>:
                            <ul>
                                <li>Disadvantage 1</li>
                                <li>Disadvantage 2</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><strong>Decision</strong>: State the chosen option and provide a detailed explanation of why it was selected.</li>
        <li><strong>Consequences</strong>: List the implications of this decision, including any follow-up tasks, risks, or long-term impacts.</li>
        <li><strong>See Also</strong>: Link related ADRs or relevant documentation for reference.</li>
    </ol>

    <h2>How to Create and Submit ADRs</h2>
    <ol>
        <li><strong>Draft the ADR</strong>:
            <ul>
                <li>Use the template above to structure your ADR.</li>
                <li>Include all options, pros/cons, and reasoning.</li>
            </ul>
        </li>
        <li><strong>Submit a Pull Request</strong>:
            <ul>
                <li>Create a branch named <code>feature/adr###-short-title</code>.</li>
                <li>Add the ADR file to the <code>/adr</code> folder in the repository.</li>
                <li>Include any diagrams (use PlantUML if needed) in the <code>/adr</code> folder.</li>
            </ul>
        </li>
        <li><strong>Review Process</strong>:
            <ul>
                <li>Open a Pull Request (PR) titled <code>ADR### - Short Title</code>.</li>
                <li>Collaborate with the team to review and finalize the decision.</li>
            </ul>
        </li>
        <li><strong>Merge</strong>:
            <ul>
                <li>After team approval, merge the PR into the main branch.</li>
            </ul>
        </li>
    </ol>

    <h2>Where to Store ADRs</h2>
    <p>All ADRs should be stored in the <code>adr</code> folder of the project repository:</p>
    <pre><code>/project-root/adr/</code></pre>
    <p>This ensures they are version-controlled and accessible.</p>

    <h2>Example ADR</h2>
    <h3>ADR001 - Use an SQS Queue to Manage Mail</h3>
    <ul>
        <li><strong>Status</strong>: Accepted</li>
        <li><strong>Context</strong>: We need to handle a large volume of email notifications reliably and asynchronously.</li>
        <li><strong>Options Considered</strong>:
            <ul>
                <li><strong>Option 1: Use an SQS Queue</strong>
                    <ul>
                        <li><strong>Pros</strong>:
                            <ul>
                                <li>Scalable</li>
                                <li>Reliable</li>
                                <li>Integrates well with AWS Lambda</li>
                            </ul>
                        </li>
                        <li><strong>Cons</strong>:
                            <ul>
                                <li>Requires additional setup and monitoring</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li><strong>Option 2: Direct Database Writes</strong>
                    <ul>
                        <li><strong>Pros</strong>:
                            <ul>
                                <li>Simpler implementation</li>
                            </ul>
                        </li>
                        <li><strong>Cons</strong>:
                            <ul>
                                <li>Less scalable</li>
                                <li>May lead to bottlenecks during peak load</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </li>
        <li><strong>Decision</strong>: Use an SQS queue because it ensures scalability and reliability for high-volume email notifications.</li>
        <li><strong>Consequences</strong>: Set up SQS and integrate with the notification service. Monitor for errors or delays.</li>
    </ul>
</body>
</html>


Got it! Let’s update the Confluence page to use a more detailed ADR template that includes options and their associated pros and cons. Here's the revised draft:


---

Architecture Decision Records (ADR) Guidelines

What is an ADR?

An Architecture Decision Record (ADR) documents architectural decisions made within a project, including the options considered, their pros and cons, and the final decision. ADRs help teams maintain a history of decisions for clarity and alignment over time.

For more details on ADRs, refer to Documenting Architecture Decisions by Michael Nygard.


---

Naming Conventions for ADRs

Each ADR should follow this naming convention:

ADR### - Short Title of the Decision

###: Incremental number starting from 001.

Short Title: Briefly describes the decision. Example:

ADR001 - Use an SQS Queue to Manage Mail

ADR002 - Choose PostgreSQL as the Database




---

ADR Template with Options

Here’s the template we will follow for ADRs:

1. Title

A clear and concise name for the decision.


2. Status

Current status of the ADR: Proposed, Accepted, Superseded, or Deprecated.


3. Context

What is the problem? Provide background information and the factors leading to this decision.

Why is this decision needed now? Explain the urgency or importance.


4. Options Considered

List the options evaluated, with their pros and cons. For each option:

Option 1: [Option Name]

Description: Brief explanation of the option.

Pros:

Advantage 1

Advantage 2


Cons:

Disadvantage 1

Disadvantage 2



Option 2: [Option Name]

Description: Brief explanation of the option.

Pros:

Advantage 1

Advantage 2


Cons:

Disadvantage 1

Disadvantage 2



(Repeat for all options considered.)

5. Decision

State the chosen option and provide a detailed explanation of why it was selected.


6. Consequences

List the implications of this decision, including any follow-up tasks, risks, or long-term impacts.


7. See Also

Link related ADRs or relevant documentation for reference.



---

How to Create and Submit ADRs

1. Draft the ADR:

Use the template above to structure your ADR.

Include all options, pros/cons, and reasoning.



2. Submit a Pull Request:

Create a branch named feature/adr###-short-title.

Add the ADR file to the /adr folder in the repository.

Include any diagrams (use PlantUML if needed) in the /adr folder.



3. Review Process:

Open a Pull Request (PR) titled ADR### - Short Title.

Collaborate with the team to review and finalize the decision.



4. Merge:

After team approval, merge the PR into the main branch.





---

Where to Store ADRs

All ADRs should be stored in the adr folder of the project repository:

/project-root/adr/

This ensures they are version-controlled and accessible.


---

Example ADR

ADR001 - Use an SQS Queue to Manage Mail

1. Status: Accepted


2. Context: We need to handle a large volume of email notifications reliably and asynchronously.


3. Options Considered:

Option 1: Use an SQS Queue

Pros: Scalable, reliable, integrates well with AWS Lambda.

Cons: Requires additional setup and monitoring.


Option 2: Direct Database Writes

Pros: Simpler implementation.

Cons: Less scalable, may lead to bottlenecks during peak load.




4. Decision: Use an SQS queue because it ensures scalability and reliability for high-volume email notifications.


5. Consequences: Set up SQS and integrate with the notification service. Monitor for errors or delays.




---

By following these guidelines, we ensure all architectural decisions are well-documented, consistent, and collaborative.
